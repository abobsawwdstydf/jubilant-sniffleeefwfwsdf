<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Рисование жестами — demo</title>
<style>
  body { margin:0; display:flex; gap:8px; height:100vh; background:#111; color:#eee;
         align-items:flex-start; justify-content:center; font-family:system-ui; padding:12px; }
  #wrap { position:relative; width:960px; max-width:95vw; }
  video, canvas { display:block; width:100%; border-radius:8px; background:#000; }
  #ui { margin-top:8px; display:flex; gap:8px; align-items:center; }
  button { padding:6px 10px; border-radius:6px; border:0; cursor:pointer; }
  .status { font-size:13px; margin-left:8px; opacity:0.9; }
  .small { font-size:12px; opacity:0.8 }
</style>
</head>
<body>
  <div id="wrap">
    <video id="video" autoplay playsinline></video>
    <canvas id="overlay"></canvas>
    <div id="ui">
      <button id="clearBtn">Очистить</button>
      <button id="toggleMirror">Зеркало: ON</button>
      <div class="status" id="mode">Режим: ожидание руки</div>
      <div class="small">Жест: сомкнуть большой + указательный = рисовать</div>
    </div>
  </div>

  <!-- MediaPipe Hands (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
  (async ()=> {
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d', { willReadFrequently: false });
    const modeLabel = document.getElementById('mode');
    const clearBtn = document.getElementById('clearBtn');
    const toggleMirror = document.getElementById('toggleMirror');

    let mirror = true;
    let drawing = false;
    let last = null; // last pointer pos for smooth line
    let drawColor = '#00ff88';
    let lineWidth = 4;

    function resizeToVideo() {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
    }

    clearBtn.onclick = () => {
      ctx.clearRect(0,0,canvas.width,canvas.height);
    };
    toggleMirror.onclick = () => {
      mirror = !mirror;
      toggleMirror.textContent = `Зеркало: ${mirror ? 'ON' : 'OFF'}`;
    };

    // init MediaPipe Hands
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.6
    });

    // helper: distance between 2 landmarks
    function dist(a,b){
      const dx = a.x - b.x, dy = a.y - b.y, dz = (a.z||0)-(b.z||0);
      return Math.sqrt(dx*dx + dy*dy + dz*dz);
    }

    // smoothing helper (lerp)
    function lerp(a,b,t){ return a + (b-a)*t; }

    hands.onResults(results => {
      if (!video.videoWidth) return;
      // initialize canvas size once video ready
      resizeToVideo();

      // draw transparent overlay (showing camera feed behind is native video element)
      // we'll draw only strokes and helper markers on overlay canvas.
      // Keep overlay cleared only for helper UI — strokes should persist.
      // So we draw helpers on a temporary canvas layer; for simplicity we clear then redraw
      // helpers, but keep an additional persistent 'strokes' canvas if needed.
      // Here we'll keep strokes on the same canvas but not clear when drawing flag false.
      // To show hand markers, create a separate temporary drawing on top of strokes:
      // We'll clone current canvas to preserve strokes, clear and redraw markers + strokes.
      // For simplicity we store strokes on an offscreen canvas.
    });

    // Implement by using two canvases: one persistent for strokes, one for helpers.
    // Replace overlay canvas with two layered canvases:
  })();
  </script>

  <script>
  // ---------- Revised: create two layered canvases dynamically ----------
  (async ()=> {
    const wrap = document.getElementById('wrap');
    const video = document.getElementById('video');
    // remove single canvas created earlier
    const oldCanvas = document.getElementById('overlay');
    if (oldCanvas) oldCanvas.remove();

    // persistent strokes canvas
    const strokes = document.createElement('canvas');
    strokes.id = 'strokes';
    strokes.style.position = 'absolute';
    strokes.style.left = 0;
    strokes.style.top = 0;
    strokes.style.pointerEvents = 'none';
    strokes.style.width = '100%';
    strokes.style.height = '100%';
    wrap.appendChild(strokes);

    // helper canvas (cleared each frame)
    const helper = document.createElement('canvas');
    helper.id = 'helper';
    helper.style.position = 'absolute';
    helper.style.left = 0;
    helper.style.top = 0;
    helper.style.pointerEvents = 'none';
    helper.style.width = '100%';
    helper.style.height = '100%';
    wrap.appendChild(helper);

    const sctx = strokes.getContext('2d');
    const hctx = helper.getContext('2d');

    // buttons from above
    const modeLabel = document.getElementById('mode');
    const clearBtn = document.getElementById('clearBtn');
    const toggleMirror = document.getElementById('toggleMirror');
    let mirror = true;

    clearBtn.onclick = ()=> { sctx.clearRect(0,0,strokes.width,strokes.height); };
    toggleMirror.onclick = ()=> { mirror = !mirror; toggleMirror.textContent = `Зеркало: ${mirror ? 'ON' : 'OFF'}`; };

    // camera start
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { width:1280, height:720 }, audio:false });
      video.srcObject = stream;
      await video.play();
    } catch (e) {
      alert('Ошибка доступа к камере: ' + e.message);
      return;
    }

    // match canvas pixel sizes to video
    function fitCanvases() {
      const w = video.videoWidth || video.clientWidth;
      const h = video.videoHeight || video.clientHeight;
      [strokes, helper].forEach(c=>{
        c.width = w;
        c.height = h;
        c.style.width = video.style.width || '100%';
        c.style.height = video.style.height || 'auto';
      });
      // adjust video style so stacked canvases align
      video.style.width = (w>0? (w)+'px' : '100%');
      video.style.height = (h>0? (h)+'px' : 'auto');
    }
    video.addEventListener('loadeddata', fitCanvases);
    window.addEventListener('resize', fitCanvases);

    // MediaPipe Hands
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.6
    });

    // camera utils to feed hands
    const camera = new Camera(video, {
      onFrame: async () => {
        await hands.send({image: video});
      },
      width: 1280,
      height: 720
    });
    camera.start();

    let prev = null; // last pointer pos in pixel coords
    const drawColor = '#00ff88';
    const lineWidth = 6;
    const smoothing = 0.25; // lerp factor when smoothing pointer movement

    function toPixel(landmark) {
      // landmarks are normalized (0..1). Convert to pixel coords
      const x = landmark.x * helper.width;
      const y = landmark.y * helper.height;
      return {x: mirror ? helper.width - x : x, y};
    }

    function dist(a,b){
      const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy);
    }

    hands.onResults(results => {
      hctx.clearRect(0,0,helper.width,helper.height);
      if (!results.multiHandLandmarks || results.multiHandLandmarks.length===0) {
        modeLabel.textContent = 'Режим: нет руки';
        prev = null;
        return;
      }
      const lm = results.multiHandLandmarks[0];

      // helpers: draw small circle at index fingertip (landmark 8) and thumb tip (4)
      const indexTip = toPixel(lm[8]);
      const thumbTip = toPixel(lm[4]);

      // gesture: draw when index and thumb close enough (pinch)
      const normDist = dist(indexTip, thumbTip) / Math.max(helper.width, helper.height);
      const pinch = normDist < 0.04; // tune threshold
      modeLabel.textContent = pinch ? 'Режим: РИСУЕМ (pinch)' : 'Режим: наведение — не рисуем';

      // draw helper markers
      hctx.beginPath();
      hctx.arc(indexTip.x, indexTip.y, 8, 0, Math.PI*2);
      hctx.fillStyle = 'rgba(0,255,136,0.8)';
      hctx.fill();
      hctx.beginPath();
      hctx.arc(thumbTip.x, thumbTip.y, 8, 0, Math.PI*2);
      hctx.fillStyle = 'rgba(255,200,0,0.8)';
      hctx.fill();
      hctx.lineWidth = 2;
      hctx.beginPath();
      hctx.moveTo(indexTip.x, indexTip.y);
      hctx.lineTo(thumbTip.x, thumbTip.y);
      hctx.strokeStyle = 'rgba(255,255,255,0.15)';
      hctx.stroke();

      // compute smoothed pointer position
      const pointer = prev ? {
        x: lerp(prev.x, indexTip.x, smoothing),
        y: lerp(prev.y, indexTip.y, smoothing)
      } : {x: indexTip.x, y: indexTip.y};

      // handle drawing on persistent canvas
      if (pinch) {
        // start new stroke if prev is null
        if (!prev) {
          sctx.beginPath();
          sctx.moveTo(pointer.x, pointer.y);
        } else {
          sctx.lineTo(pointer.x, pointer.y);
          sctx.strokeStyle = drawColor;
          sctx.lineWidth = lineWidth;
          sctx.lineCap = 'round';
          sctx.lineJoin = 'round';
          sctx.stroke();
        }
      } else {
        // lift pen
        prev = null;
      }

      prev = pointer;
    });

    // simple lerp
    function lerp(a,b,t){ return a + (b-a)*t; }

    // done
  })();
  </script>
</body>
</html>
