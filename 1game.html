<!DOCTYPE html> <html> <head> <meta charset="utf-8" /> <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <!--metatextblock--> <title>Dark Heavens: GAME</title> <meta property="og:url" content="https://darkheavens.ru/1game" /> <meta property="og:title" content="Dark Heavens: GAME" /> <meta property="og:description" content="" /> <meta property="og:type" content="website" /> <link rel="canonical" href="1game.html"> <!--/metatextblock--> <meta name="format-detection" content="telephone=no" /> <meta http-equiv="x-dns-prefetch-control" content="on"> <link rel="dns-prefetch" href="https://ws.tildacdn.com"> <link rel="dns-prefetch" href="https://static.tildacdn.info"> <link rel="shortcut icon" href="https://static.tildacdn.info/tild3536-3666-4131-a563-363038303565/server.png" type="image/x-icon" /> <link rel="alternate" type="application/rss+xml" title="Dark Heavens" href="rss.xml" /> <!-- Assets --> <script src="https://neo.tildacdn.com/js/tilda-fallback-1.0.min.js" async charset="utf-8"></script> <link rel="stylesheet" href="https://static.tildacdn.info/css/tilda-grid-3.0.min.css" type="text/css" media="all" onerror="this.loaderr='y';"/> <link rel="stylesheet" href="https://static.tildacdn.info/ws/project12269285/tilda-blocks-page63714249.min.css?t=1740200353" type="text/css" media="all" onerror="this.loaderr='y';" /> <link rel="stylesheet" href="https://static.tildacdn.info/css/fonts-tildasans.css" type="text/css" media="all" onerror="this.loaderr='y';" /> <script nomodule src="https://static.tildacdn.info/js/tilda-polyfill-1.0.min.js" charset="utf-8"></script> <script type="text/javascript">function t_onReady(func) {if(document.readyState!='loading') {func();} else {document.addEventListener('DOMContentLoaded',func);}}
function t_onFuncLoad(funcName,okFunc,time) {if(typeof window[funcName]==='function') {okFunc();} else {setTimeout(function() {t_onFuncLoad(funcName,okFunc,time);},(time||100));}}</script> <script src="https://static.tildacdn.info/js/tilda-scripts-3.0.min.js" charset="utf-8" defer onerror="this.loaderr='y';"></script> <script src="https://static.tildacdn.info/ws/project12269285/tilda-blocks-page63714249.min.js?t=1740200353" charset="utf-8" async onerror="this.loaderr='y';"></script> <script src="https://static.tildacdn.info/js/tilda-lazyload-1.0.min.js" charset="utf-8" async onerror="this.loaderr='y';"></script> <script src="https://static.tildacdn.info/js/tilda-events-1.0.min.js" charset="utf-8" async onerror="this.loaderr='y';"></script> <script type="text/javascript">window.dataLayer=window.dataLayer||[];</script> <script type="text/javascript">(function() {if((/bot|google|yandex|baidu|bing|msn|duckduckbot|teoma|slurp|crawler|spider|robot|crawling|facebook/i.test(navigator.userAgent))===false&&typeof(sessionStorage)!='undefined'&&sessionStorage.getItem('visited')!=='y'&&document.visibilityState){var style=document.createElement('style');style.type='text/css';style.innerHTML='@media screen and (min-width: 980px) {.t-records {opacity: 0;}.t-records_animated {-webkit-transition: opacity ease-in-out .2s;-moz-transition: opacity ease-in-out .2s;-o-transition: opacity ease-in-out .2s;transition: opacity ease-in-out .2s;}.t-records.t-records_visible {opacity: 1;}}';document.getElementsByTagName('head')[0].appendChild(style);function t_setvisRecs(){var alr=document.querySelectorAll('.t-records');Array.prototype.forEach.call(alr,function(el) {el.classList.add("t-records_animated");});setTimeout(function() {Array.prototype.forEach.call(alr,function(el) {el.classList.add("t-records_visible");});sessionStorage.setItem("visited","y");},400);}
document.addEventListener('DOMContentLoaded',t_setvisRecs);}})();</script></head> <body class="t-body" style="margin:0;"> <!--allrecords--> <div id="allrecords" class="t-records" data-hook="blocks-collection-content-node" data-tilda-project-id="12269285" data-tilda-page-id="63714249" data-tilda-page-alias="1game" data-tilda-formskey="8902764f93d4c7591a048e5312269285" data-tilda-cookie="no" data-tilda-lazy="yes" data-tilda-root-zone="com"> <div id="rec870030317" class="r t-rec" style=" " data-animationappear="off" data-record-type="131"> <!-- T123 --> <div class="t123"> <div class="t-container_100 "> <div class="t-width t-width_100 "> <!-- nominify begin --> <!DOCTYPE html> <html> <head> <title>Color Chaos</title> <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: sans-serif;
            color: #eee;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #score, #level {
            font-size: 16px;
        }

        #xp-bar {
            width: 200px;
            height: 10px;
            background-color: #444;
            border-radius: 5px;
            overflow: hidden;
        }

        #xp-bar-fill {
            width: 0%;
            height: 100%;
            background-color: #ffcc00;
            transition: width 0.3s ease;
        }

        #achievements {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            max-height: 150px;
            overflow-y: auto;
        }

        .achievement {
            font-size: 14px;
            margin-bottom: 5px;
        }

        .achievement::before {
            content: "???? ";
        }

        #language-select {
            background-color: #444;
            color: #eee;
            border: none;
            padding: 5px;
            border-radius: 3px;
            cursor: pointer;
        }

        #combo {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            color: #fff;
            text-shadow: 2px 2px 4px #000000;
            opacity: 0; /* Скрыто по умолчанию */
            transition: opacity 0.5s ease-in-out;
        }

        /* === Стили для джойстиков === */
        .joystick {
            position: absolute;
            width: 100px;
            height: 100px;
            background-color: rgba(50, 50, 50, 0.5);
            border-radius: 50%;
            touch-action: none; /* Предотвращает прокрутку страницы при касании */
        }

        .joystick-left {
            bottom: 20px;
            left: 20px;
        }

        .joystick-right {
            bottom: 20px;
            right: 20px;
        }

        .joystick-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background-color: rgba(150, 150, 150, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /*  чтобы не мешал касаниям */
        }
    </style> </head> <body> <div id="ui"> <label for="language-select">Language:</label> <select id="language-select"> <option value="en">English</option> <option value="ru">Русский</option> </select> <div id="score">Score: 0</div> <div id="level">Level: 1</div> <div id="xp-bar"> <div id="xp-bar-fill"></div> </div> </div> <div id="achievements"> <!-- Achievements will be added here dynamically --> </div> <div id="combo">Combo! x1</div> <canvas id="gameCanvas"></canvas> <!--  Добавляем джойстики --> <div id="joystick-left" class="joystick joystick-left"> <div class="joystick-handle"></div> </div> <div id="joystick-right" class="joystick joystick-right"> <div class="joystick-handle"></div> </div> <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        // === Настройки игры ===
        const foodColor = "green";
        const initialPlayerSize = 20;
        const foodSize = 5;
        const playerSpeed = 3;
        const foodCount = 100;
        const boostSpeedMultiplier = 2;
        const boostDuration = 150;
        const expPerFood = 5;
        const levelUpThreshold = 100;
        const maxLevel = 25;
        const safeSpawnDistance = 50;

         // === Настройки комбо ===
        let comboCount = 0;
        let comboTimer = 0;
        const comboDuration = 50; //  кадров
        const comboElement = document.getElementById("combo");


        // === Настройки мин ===
        const mineColors = {
            normal: "red",
            slow: "purple",
            push: "orange"
        };
        const mineSize = 15;
        const mineCount = 10;
        const mineSpawnInterval = 200; // Интервал спавна новых мин (кадров)
        let mineSpawnTimer = 0;

        // Вероятности типов мин (должны в сумме давать 1)
        const mineTypeProbabilities = {
            normal: 0.7,
            slow: 0.2,
            push: 0.1
        };

        const mineDamage = 0.2;
        const slowMineDuration = 150; //  кадров
        const pushMineForce = 5;

        // === Визуальные эффекты ===
        const particleCount = 15;
        const particles = [];

        // === Локализация ===
        let currentLanguage = "en";
        const languageSelect = document.getElementById("language-select");
        const translations = {
            en: {
                score: "Score: ",
                level: "Level: ",
                bigBoy: "Big Boy: Reach size 50!",
                level5: "Level 5 Reached!",
                score100: "100 Points Scored!",
                leaderboard: "Leaderboard"
            },
            ru: {
                score: "Счет: ",
                level: "Уровень: ",
                bigBoy: "Большой мальчик: Достигни размера 50!",
                level5: "Достигнут 5-й уровень!",
                score100: "Набрано 100 очков!",
                leaderboard: "Leaderboard"
            }
        };

        function updateText() {
            const lang = translations[currentLanguage];
            scoreElement.textContent = lang.score + player.score;
            levelElement.textContent = lang.level + player.level;
        }

        languageSelect.addEventListener("change", () => {
            currentLanguage = languageSelect.value;
            updateText();
        });

        // === Градиенты для фона ===
        const backgroundGradients = [
            ["#2980B9", "#6DD5FA"],
            ["#FF5F6D", "#FFC371"],
            ["#4CA1AF", "#C4E0E5"],
            ["#6441A5", "#2A0845"],
            ["#00c6fb", "#005bea"]
        ];

        let currentGradient = backgroundGradients[0];

        function setBackground() {
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, currentGradient[0]);
            gradient.addColorStop(1, currentGradient[1]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // === Наборы форм и цветов игрока ===
        const playerColors = ["blue", "red", "yellow", "purple", "orange"];
        const playerShapes = ["triangle", "square", "pentagon", "star"];

        function getPlayerShape(level) {
            const index = (level - 1) % playerShapes.length;
            return playerShapes[index];
        }

        function getPlayerColor(level) {
            const index = (level - 1) % playerColors.length;
            return playerColors[index];
        }

        // ===  Функции для работы с частицами ===
        function createParticles(x, y, color) {
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: x,
                    y: y,
                    color: color,
                    size: Math.random() * 3,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    alpha: 1
                });
            }
        }

        function updateParticles() {
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= 0.02;

                if (p.alpha <= 0) {
                    particles.splice(i, 1);
                    i--;
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.alpha;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                ctx.globalAlpha = 1; // Reset alpha
            });
        }

        // === Массивы и объекты ===
        let food = [];
        let players = {};
        let mines = [];

        let player = {
            id: generateId(),
            x: canvas.width / 2,
            y: canvas.height / 2,
            size: initialPlayerSize,
            color: "blue",
            speed: playerSpeed,
            originalSpeed: playerSpeed, // Для замедления
            isBoosting: false,
            boostTimer: 0,
            score: 0,
            level: 1,
            exp: 0,
            nextLevelExp: levelUpThreshold,
            moveX: 0,
            moveY: 0,
            shape: "triangle",
            slowedTimer: 0 // Таймер замедления
        };
        players[player.id] = player;

        // === Достижения ===
        const achievementsList = [];
        const achievementElement = document.getElementById("achievements");

        // === UI элементы ===
        const scoreElement = document.getElementById("score");
        const levelElement = document.getElementById("level");
        const xpBarFill = document.getElementById("xp-bar-fill");

        // === Управление ===
        let keyState = {};
        let gamepad;

        // === Мобильные джойстики ===
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let joystickLeft = document.getElementById("joystick-left");
        let joystickRight = document.getElementById("joystick-right");
        let joystickLeftHandle = joystickLeft.querySelector(".joystick-handle");
        let joystickRightHandle = joystickRight.querySelector(".joystick-handle");

        let moveX = 0;
        let moveY = 0;
        let isBoosting = false;

        if (isMobile) {
            // === Левый джойстик (движение) ===
            joystickLeft.addEventListener("touchstart", (e) => {
                e.preventDefault(); // Предотвращаем прокрутку страницы
                handleJoystickMove(e, joystickLeft, joystickLeftHandle, "move");
            }, { passive: false });

            joystickLeft.addEventListener("touchmove", (e) => {
                e.preventDefault();
                handleJoystickMove(e, joystickLeft, joystickLeftHandle, "move");
            }, { passive: false });

            joystickLeft.addEventListener("touchend", (e) => {
                e.preventDefault();
                resetJoystick(joystickLeftHandle);
                moveX = 0;
                moveY = 0;
            }, { passive: false });

             // === Правый джойстик (ускорение) ===
            joystickRight.addEventListener("touchstart", (e) => {
                e.preventDefault();
                handleJoystickMove(e, joystickRight, joystickRightHandle, "boost");
                isBoosting = true;
            }, { passive: false });

            joystickRight.addEventListener("touchmove", (e) => {
                e.preventDefault();
                handleJoystickMove(e, joystickRight, joystickRightHandle, "boost");
            }, { passive: false });

            joystickRight.addEventListener("touchend", (e) => {
                e.preventDefault();
                resetJoystick(joystickRightHandle);
                isBoosting = false;
            }, { passive: false });

        } else {
            // Скрываем джойстики на не-мобильных устройствах
            joystickLeft.style.display = "none";
            joystickRight.style.display = "none";
        }

        function handleJoystickMove(event, joystick, handle, type) {
            let touch = event.touches[0];
            let rect = joystick.getBoundingClientRect();
            let x = touch.clientX - rect.left;
            let y = touch.clientY - rect.top;
            let dx = x - rect.width / 2;
            let dy = y - rect.height / 2;
            let distance = Math.sqrt(dx * dx + dy * dy);

            let maxDistance = rect.width / 2;
            if (distance > maxDistance) {
                dx = (dx / distance) * maxDistance;
                dy = (dy / distance) * maxDistance;
            }

            handle.style.transform = `translate(${dx}px, ${dy}px)`;

            if (type === "move") {
                moveX = dx / maxDistance;
                moveY = dy / maxDistance;
            }
        }

        function resetJoystick(handle) {
            handle.style.transform = "translate(-50%, -50%)";
        }

        // === Вспомогательные функции ===
        function generateId() {
            return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        }

        function distance(x1, y1, x2, y2) {
            const dx = x1 - x2;
            const dy = x1 - x2;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // === Функции создания ===
        function createFood() {
            for (let i = 0; i < foodCount; i++) {
                let x, y;
                do {
                    x = Math.random() * canvas.width;
                    y = Math.random() * canvas.height;
                } while (distance(player.x, player.y, x, y) < safeSpawnDistance);

                food.push({
                    x: x,
                    y: y,
                    size: foodSize,
                    color: foodColor,
                    shape: "square"
                });
            }
        }


        function createMine(type) {
            let x, y;
            do {
                x = Math.random() * canvas.width;
                y = Math.random() * canvas.height;
            } while (distance(player.x, player.y, x, y) < safeSpawnDistance); // Не спавнить слишком близко к игроку

            return {
                x: x,
                y: y,
                size: mineSize,
                type: type
            };
        }


        function spawnMine() {
            let type = "normal";
            const rand = Math.random();

            if (rand < mineTypeProbabilities.normal) {
                type = "normal";
            } else if (rand < mineTypeProbabilities.normal + mineTypeProbabilities.slow) {
                type = "slow";
            } else {
                type = "push";
            }

            mines.push(createMine(type));
        }

        // === Обработчики событий ===
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Keyboard
        document.addEventListener("keydown", (e) => {
            keyState[e.code] = true;
            if (e.code === "Space" && !player.isBoosting) {
                player.isBoosting = true;
                player.boostTimer = boostDuration;
            }
        });

        document.addEventListener("keyup", (e) => {
            keyState[e.code] = false;
        });

        // Gamepad
        function gamepadConnected(e) {
            gamepad = navigator.getGamepads()[e.gamepad.index];
            console.log("Gamepad connected:", gamepad);
        }

        function gamepadDisconnected(e) {
            gamepad = null;
            console.log("Gamepad disconnected:", e.gamepad);
        }

        window.addEventListener("gamepadconnected", gamepadConnected);
        window.addEventListener("gamepaddisconnected", gamepadDisconnected);

        // === Достижения ===
        function checkAchievements() {
            if (player.size > 50 && !achievementsList.includes("bigBoy")) {
                achievementsList.push("bigBoy");
                addAchievement(translations[currentLanguage].bigBoy);
                player.speed += 0.2;
            }

            if (player.level >= 5 && !achievementsList.includes("level5")) {
                achievementsList.push("level5");
                addAchievement(translations[currentLanguage].level5);
                player.speed += 0.1;
            }

             if (player.score >= 100 && !achievementsList.includes("100score")) {
                achievementsList.push("100score");
                addAchievement(translations[currentLanguage].score100);
                player.speed += 0.1;
            }
        }

        function addAchievement(text) {
            const achievementDiv = document.createElement("div");
            achievementDiv.classList.add("achievement");
            achievementDiv.textContent = "???? " + text;
            achievementElement.appendChild(achievementDiv);

            setTimeout(() => {
                achievementDiv.remove();
            }, 5000);
        }

        // === Логика игры ===
        function update() {
            // === Управление ===
            let dx = 0;
            let dy = 0;
            let boosting = false;

            // Mobile
            if (isMobile) {
                dx = moveX;
                dy = moveY;
                boosting = isBoosting;
            } else {

             // Keyboard
                player.moveX = 0;
                player.moveY = 0;

                if (keyState["KeyA"] || keyState["ArrowLeft"])  player.moveX = -1;
                if (keyState["KeyD"] || keyState["ArrowRight"]) player.moveX = 1;
                if (keyState["KeyW"] || keyState["ArrowUp"])    player.moveY = -1;
                if (keyState["KeyS"] || keyState["ArrowDown"])  player.moveY = 1;

                dx = player.moveX;
                dy = player.moveY;

                 // Keyboard boost
                boosting = keyState["Space"];

            }

            // Movement and boost
            let distanceToTarget = Math.sqrt(dx * dx + dy * dy);
            if (distanceToTarget > 0) {
                let vx = dx / distanceToTarget;
                let vy = dy / distanceToTarget;

                let currentSpeed = player.speed;
                if (boosting && !player.isBoosting) {
                     player.isBoosting = true;
                     player.boostTimer = boostDuration;
                }


                if (player.isBoosting) {
                    currentSpeed *= boostSpeedMultiplier;
                    player.boostTimer--;
                    if (player.boostTimer <= 0) {
                        player.isBoosting = false;
                    }
                }

                let nextX = player.x + vx * currentSpeed;
                let nextY = player.y + vy * currentSpeed;

                player.x = Math.max(player.size, Math.min(canvas.width - player.size, nextX));
                player.y = Math.max(player.size, Math.min(canvas.height - player.size, nextY));
            }



             // Поедание еды
            for (let i = 0; i < food.length; i++) {
                let f = food[i];
                if (distance(player.x, player.y, f.x, f.y) < player.size + f.size) {
                    // COMBO SYSTEM
                    comboCount++;
                    comboTimer = comboDuration; // Reset timer
                    let comboMultiplier = 1;
                    if (comboCount > 5) comboMultiplier = 2;
                    if (comboCount > 10) comboMultiplier = 3;

                    showCombo(comboMultiplier);

                    player.size += f.size / 5;

                     player.score += 10 * comboMultiplier; // Умножаем очки на комбо-множитель
                    scoreElement.textContent = translations[currentLanguage].score + player.score;

                    player.exp += expPerFood;
                     xpBarFill.style.width = `${(player.exp / player.nextLevelExp) * 100}%`;

                     if (player.exp >= player.nextLevelExp && player.level < maxLevel) {
                        player.level++;
                        player.shape = getPlayerShape(player.level);
                        player.color = getPlayerColor(player.level);

                        player.exp = 0;
                        player.nextLevelExp = levelUpThreshold * player.level;
                        levelElement.textContent = translations[currentLanguage].level + player.level;
                         player.originalSpeed *= 1.02; // Чуть-чуть ускоряемся с каждым уровнем
                         player.speed = player.originalSpeed;
                    }

                   //  Случайное смещение еды
                    f.x = Math.random() * canvas.width;
                    f.y = Math.random() * canvas.height;

                    // Снова проверяем, чтобы не спавнилась под игроком
                    while (distance(player.x, player.y, f.x, f.y) < safeSpawnDistance) {
                        f.x = Math.random() * canvas.width;
                        f.y = Math.random() * canvas.height;
                    }
                }
            }

            // Комбо таймер
            if (comboTimer > 0) {
                comboTimer--;
            } else {
                comboCount = 0;
                hideCombo();
            }

            // === Обновление мин ===
            mineSpawnTimer++;
            if (mineSpawnTimer > mineSpawnInterval) {
                spawnMine();
                mineSpawnTimer = 0;
            }

            // Столкновение с минами
            for (let i = 0; i < mines.length; i++) {
                let mine = mines[i];
                if (distance(player.x, player.y, mine.x, mine.y) < player.size + mine.size) {

                    createParticles(mine.x, mine.y, mineColors[mine.type]);

                    switch (mine.type) {
                        case "normal":
                            player.size *= (1 - mineDamage);
                            break;
                        case "slow":
                            player.speed *= 0.5; // Уменьшаем скорость вдвое
                            player.slowedTimer = slowMineDuration;
                            break;
                        case "push":
                            let angle = Math.atan2(player.y - mine.y, player.x - mine.x);
                            player.x += Math.cos(angle) * pushMineForce;
                            player.y += Math.sin(angle) * pushMineForce;
                            break;
                    }

                     mines.splice(i, 1);

                    spawnMine();
                }
            }

            // === Таймеры эффектов ===
            if (player.slowedTimer > 0) {
                player.slowedTimer--;
                if (player.slowedTimer === 0) {
                    player.speed = player.originalSpeed; // Восстанавливаем скорость
                }
            }

             updateParticles();

            players[player.id] = player;
            checkAchievements();

            if (Math.random() < 0.005) {
                currentGradient = backgroundGradients[Math.floor(Math.random() * backgroundGradients.length)];
            }
        }

        // === UI ===
        function showCombo(multiplier) {
            comboElement.textContent = `Combo! x${multiplier}`;
            comboElement.style.opacity = 1;
        }

        function hideCombo() {
            comboElement.style.opacity = 0;
        }

        // === Отрисовка ===
        function draw() {
            setBackground();

             drawParticles();

            // Отрисовка еды
            food.forEach(f => {
                ctx.fillStyle = f.color;
                ctx.fillRect(f.x - f.size / 2, f.y - f.size / 2, f.size, f.size);
            });

             // Отрисовка мин
            mines.forEach(mine => {
                ctx.fillStyle = mineColors[mine.type]; //  в зависимости от типа
                ctx.beginPath();
                ctx.moveTo(mine.x, mine.y - mine.size);
                ctx.lineTo(mine.x + mine.size, mine.y);
                ctx.lineTo(mine.x, mine.y + mine.size);
                ctx.lineTo(mine.x - mine.size, mine.y);
                ctx.closePath();
                ctx.fill();
            });


            // Отрисовка игроков
            for (const playerId in players) {
                const p = players[playerId];
                ctx.fillStyle = p.color;

                ctx.beginPath();
                switch (p.shape) {
                    case "triangle":
                        ctx.moveTo(p.x + p.size * Math.cos(0), p.y + p.size * Math.sin(0));
                        ctx.lineTo(p.x + p.size * Math.cos(2 * Math.PI / 3), p.y + p.size * Math.sin(2 * Math.PI / 3));
                        ctx.lineTo(p.x + p.size * Math.cos(4 * Math.PI / 3), p.y + p.size * Math.sin(4 * Math.PI / 3));
                        break;
                    case "square":
                        ctx.rect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
                        break;
                    case "pentagon":
                        for (let i = 0; i < 5; i++) {
                            const angle = i * 2 * Math.PI / 5 - Math.PI / 2;
                            const x = p.x + p.size * Math.cos(angle);
                            const y = p.y + p.size * Math.sin(angle);
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        break;
                    case "star":
                         const spikes = 5;
                        const outerRadius = p.size;
                        const innerRadius = p.size / 2;
                        let rot = Math.PI / 2 * 3;
                         let x = p.x;
                         let y = p.y;
                         let step = Math.PI / spikes;

                         ctx.moveTo(x, y - outerRadius)

                        for (i = 0; i < spikes; i++) {
                            x = p.x + Math.cos(rot) * outerRadius;
                            y = p.y + Math.sin(rot) * outerRadius;
                            ctx.lineTo(x, y)
                            rot += step

                            x = p.x + Math.cos(rot) * innerRadius;
                            y = p.y + Math.sin(rot) * innerRadius;
                            ctx.lineTo(x, y)
                            rot += step
                        }
                        ctx.lineTo(p.x, p.y - outerRadius);
                        break;

                }
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = "#fff";
                ctx.textAlign = "center";
                ctx.fillText(`${playerId.substring(0, 8)} (Lv. ${p.level})`, p.x, p.y - p.size - 5);
            }

            if (player.isBoosting) {
                ctx.fillStyle = "rgba(255, 255, 0, 0.5)";
                ctx.fillRect(player.x - player.size, player.y + player.size + 5, player.size * 2 * (player.boostTimer / boostDuration), 5);
            }
        }

        // === Инициализация ===
        createFood();
         for (let i = 0; i < mineCount; i++) {
            spawnMine();
        }
        updateText();
        setBackground();

        // === Игровой цикл ===
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script> </body> </html> <!-- nominify end --> </div> </div> </div> </div> <div id="rec870030673" class="r t-rec" style=" " data-animationappear="off" data-record-type="131"> <!-- T123 --> <div class="t123"> <div class="t-container_100 "> <div class="t-width t-width_100 "> <!-- nominify begin --> <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <style>
        body {
            margin: 0;
            padding: 0;
            position: relative; /* Необходимо для overlay */
        }
        iframe {
            width: 100%;
            height: 100vh;
            border: none;
        }
        .overlay {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 25px; /* Высота блока текста */
            background-color: black; /* Цвет фона, чтобы скрыть оригинальный текст */
            color: white; /* Цвет текста на overlay */
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10; /* Чтобы блок был поверх iframe */
            font-size: 12px;
        }
    </style> </head> <body> <!-- Overlay с заменой текста --> <div class="overlay">
        @ Dark Heavens 2025 @haker_one
    </div> 
    </body> </html>
